---
title: "tidy_data"
author: "chuqi"
date: "2025-09-23"
output:
  word_document: default
  pdf_document: default
---
示例
我将继续使用与数据导入和数据处理相同的仓库/项目，但会创建一个新的.Rmd文件用于整理。同时，我将加载一些相关包，并限制tibble中打印的行数。
```{r}
library(tidyverse)

options(tibble.print_min = 5)
```

## pivot_longer
pivot_longer(...)
这是 tidyr 包中的一个函数，用于将数据框从“宽格式（wide format）”转换为“长格式（long format）”。

在数据导入过程中，我们使用haven包从.sas7bdat文件加载了PULSE生物标志物数据集。
现在让我们重新加载这些数据并深入分析：
```{r}
pulse_df = 
  haven::read_sas("./data/public_pulse_data.sas7bdat") |>
  janitor::clean_names()

pulse_df
```

基于对整洁数据的新认识，我们很快发现了一个问题：BDI评分分散在四个列中，分别对应四个观察时间点。
我们可以使用pivot_longer函数解决这个问题：
```{r}
pulse_tidy_df = 
  pivot_longer(
    pulse_df,                            # 原始数据框
    bdi_score_bl:bdi_score_12m,         # 选取要转换的列，从 bdi_score_bl 到 bdi_score_12m
    names_to = "visit",                 # 新建一列名为 visit，用来存放原来的列名
    values_to = "bdi"                   # 新建一列名为 bdi，用来保存原来的数值（如 12、15 等）
  )

pulse_tidy_df
```

看起来好多了！然而，现在visit有一个问题。原始列名虽然信息量很大，但我们可能不需要bdi_score_在每种情况下都保留前缀。我将使用一个附加选项来pivot_longer解决这个问题：
```{r}
pulse_tidy_df = 
  pivot_longer(
    pulse_df,                              # 原始数据框，包含多个时间点的抑郁评分（bdi）
    bdi_score_bl:bdi_score_12m,            # 要转换的列范围，从基线（bl）到12个月（12m）
    names_to = "visit",                    # 创建新变量 visit，用来保存原来的列名（如 bdi_score_bl）
    names_prefix = "bdi_score_",           # 去掉原列名前缀 "bdi_score_"，只保留后面的部分（如 bl、6m、12m）
    values_to = "bdi"                      # 创建新变量 bdi，用来存放原来各列中的数值
  )

pulse_tidy_df
```

在前面，我保存了中间数据集，以便清晰地展示每个步骤。
虽然这在您尝试代码时可能有所帮助，但通常来说，这不是一个好习惯。
为了完成数据整理过程，还需要进行一些额外的转换，例如，为了在访问中保持一致性，将其更改为，以及转换bl为因子变量。
（您可能希望将其转换为数值变量，这可以通过调用 来完成 。）00mvisitvisitmutate

总之，下面的代码将导入、整理并将 PULSE 数据集转换为可用格式：
```{r}
pulse_df = 
  haven::read_sas("./data/public_pulse_data.sas7bdat") |>  # 读取 SAS 格式的数据文件
  janitor::clean_names() |>                                # 清理列名（全部转为小写、下划线格式，更易用）
  
  pivot_longer(                                            # 宽转长，把多个列转为两列（visit 和 bdi）
    bdi_score_bl:bdi_score_12m,                            # 选中从 bdi_score_bl 到 bdi_score_12m 的列
    names_to = "visit",                                    # 将原来的列名存入新列 visit
    names_prefix = "bdi_score_",                           # 去掉列名前缀 "bdi_score_"，只留下 bl、6m、12m
    values_to = "bdi"                                      # 将原列中的数值存入新列 bdi
  ) |>
  
  relocate(id, visit) |>                                   # 调整列顺序，把 id 和 visit 移到最前面
  
  mutate(                                                  # mutate：变出新列、改已有列
    visit = replace(visit, visit == "bl", "00m"),          # 将 visit 中的 "bl"（基线）替换为 "00m"
    visit = factor(visit)                                  # 把 visit 列转换为因子（方便后续排序或分组分析）
  )

print(pulse_df, n = 12)  # 打印 pulse_df 的前 12 行数据
```

现在我们的状况还不错:-)。



##学习评估：

在窝仔数据中，变量gd0_weight和gd18_weight分别表示母鼠在妊娠第0天和第18天的体重。
编写一个数据清理链，仅保留litter_number和这些列；生成新的变量gd和weight；
并创建和的gd数值变量（对于最后一部分，你可能想使用……）。
这个版本“整洁”吗？018recode



## 解决方案

pivot_wider

我们一直以来都专注于整理数据，但我们也承认，有时不整洁的数据更利于人类阅读。
因此，我们将稍微偏离主题，谈谈如何整理你的整洁数据。

下面的代码创建了一个整洁的数据集，可用于分析。这是进行进一步分析或可视化的正确格式，但不利于人类读者进行快速比较。
```{r}
analysis_result =                         # 创建一个新的数据框（tibble），赋值给变量 analysis_result
  tibble(                                 # 使用 tibble() 函数，生成一个简洁的表格数据结构
    group = c("treatment", "treatment", "placebo", "placebo"),  # 定义一列 group，包含4个元素，表示组别
    time = c("pre", "post", "pre", "post"),                     # 定义一列 time，表示时间点（干预前后）
    mean = c(4, 8, 3.5, 4)                                      # 定义一列 mean，表示对应组别和时间的平均值
  )

analysis_result                          # 输出数据框内容，查看创建的 tibble
```

相同数据的另一种呈现方式可能是将组放在行中，将时间放在列中，并将平均值放在表格单元格中。这显然不够整洁；
为了实现这一点，我们需要使用 pivot_wider，它是pivot_longer的逆：
```{r}
pivot_wider(
  analysis_result,          # 输入数据框，长格式的分析结果
  names_from = "time",      # 将 "time" 列的不同值（如 "pre", "post"）变成新的列名
  values_from = "mean"      # 新列对应的值取自 "mean" 列
)
```

现在我们已经基本完成了 - 在某些情况下，您可能会使用它 select来重新排序列，并且（取决于您的目标）使用它 knitr::kable()来生成更美观的阅读表格。



## Binding rows
我们研究了单表非整洁数据，但非整洁性通常源于分散在多个表中的相关数据。在最简单的情况下，这些表基本相同，可以堆叠起来生成一个整洁的数据集。这就是中的设置LotR_words.xlsx，其中三部曲中每部电影中不同种族和性别的字数分布在不同的数据矩形中（这些数据基于此示例）。

为了生成所需的整洁数据集，我们首先需要读取每个表并进行一些清理。
```{r}
fellowship_ring = 
  readxl::read_excel("./data/LotR_Words.xlsx", range = "B3:D6") |>
  mutate(movie = "fellowship_ring")

two_towers = 
  readxl::read_excel("./data/LotR_Words.xlsx", range = "F3:H6") |>
  mutate(movie = "two_towers")

return_king = 
  readxl::read_excel("./data/LotR_Words.xlsx", range = "J3:L6") |>
  mutate(movie = "return_king")
```

这里需要为每个数据框添加一个变量来指示电影；这些信息存储在原始电子表格的其他位置。
顺便说一句，上面的三个代码片段除了范围和电影名称之外基本相同——稍后我们将看到一种更好的方法来处理这种情况，
即编写我们自己的函数，但目前这种方法已经可以正常工作。

一旦每个表都准备好了，我们就可以使用它们堆叠起来 bind_rows并整理结果：
```{r}
lotr_tidy = 
  bind_rows(fellowship_ring, two_towers, return_king) |>        # 合并三个数据框，按行绑定（堆叠）
  janitor::clean_names() |>                                     # 清理列名，转换为小写加下划线格式
  relocate(movie) |>                                            # 将 movie 列移动到最前面
  pivot_longer(
    female:male,                                                # 将 female 到 male 这两列转换成长格式
    names_to = "gender",                                        # 新建变量 gender，存放原列名（female/male）
    values_to = "words"                                         # 新建变量 words，存放原列对应的数值
  ) |> 
  mutate(race = str_to_lower(race)) |>                         # 把 race 列的字符串转换成小写
  select(movie, everything())                                  # 把 movie 列放到最前，其他列保持原顺序

lotr_tidy                                                    # 查看转换后的整洁数据框
```

有了这种形式的数据，我们就可以更轻松地对电影之间进行比较、对三部曲中的种族进行汇总以及执行其他分析。



## Joining datasets
数据可能分布在多个相关表中，在这种情况下，需要在分析之前对它们进行合并或连接。
我们将只关注合并两个表的问题；
合并三个或更多表的步骤将使用相同的思路逐步完成。

有四种主要方式连接数据框x和y：

内部：保留同时出现在数据中的x和y
左：保留出现在x
右：保留出现在y
完整：保留出现在数据中的x和y
左连接是最常见的，因为它们将较小表中的数据添加y到较大表中，x而不会从中删除任何内容x。

举例来说，考虑FAS_pups.csv 和中的数据表FAS_litters.csv，它们通过Litter Number变量关联。
前者包含每只幼崽独有的数据，后者包含每窝幼崽独有的数据。我们可以使用左连接将窝仔数据与幼崽数据合并；
这样做可以保留每只幼崽的数据，并在新列中添加数据。

（在重新审视这个例子时，请查看group窝仔数据集中的变量：
它编码了剂量和治疗日期！我们将在处理流程中修复这个混乱的部分。
我还将解决我的一个烦恼，即将性别编码为一个模棱两可的数字变量。）

```{r}
pup_df = 
  read_csv(                                                          # 读取 CSV 文件 FAS_pups.csv
    "./data/FAS_pups.csv",                                           # 文件路径
    skip = 3,                                                        # 跳过前三行（可能是标题或说明）
    na = c("NA", "", ".")) |>                                        # 将 "NA"、空字符串和 "." 识别为缺失值
  janitor::clean_names() |>                                          # 清理列名，转为小写加下划线格式
  mutate(sex = recode(sex, `1` = "male", `2` = "female"))            # 把 sex 列中数字转换为文字 

litter_df = 
  read_csv(                                                          # 读取 CSV 文件 FAS_litters.csv
    "./data/FAS_litters.csv",                                        # 文件路径
    na = c("NA", ".", "")) |>                                        # 将 "NA"、"."、空字符串识别为缺失值
  janitor::clean_names() |>                                          # 清理列名，转为小写加下划线格式
  relocate(litter_number) |>                                         # 将 litter_number 列移到最前面
  separate(group, into = c("dose", "day_of_tx"), sep = 3) |>         # 按第3个字符拆分 group 列，生成 dose 和 day_of_tx 两列
  mutate(                                                            # 创建或修改列
    wt_gain = gd18_weight - gd0_weight,                              # 计算体重增加：第18天体重减去第0天体重
    dose = str_to_lower(dose)                                        # 将 dose 列转换为小写
  )

```
join them!

```{r}
fas_df = 
  left_join(pup_df, litter_df, by = "litter_number") |>     # 按 litter_number 列左连接 pup_df 和 litter_df，合并两个数据框
  arrange(litter_number) |>                                 # 按 litter_number 升序排列行
  relocate(litter_number, dose)                             # 将 litter_number 和 dose 列移到最前面

fas_df                                                      # 查看合并整理后的数据框

```

我们在连接操作中明确指定了键。
默认情况下， *_join连接操作中的函数dplyr会尝试根据待连接数据集中的变量名来确定键。
这通常足够了，但并非总是如此，额外的步骤来明确键将有助于您和其他人阅读您的代码。

请注意，连接对于操作员来说并不是特别合适， |>因为它从根本上来说是非线性的：两个独立的数据集结合在一起，而不是逐步处理单个数据集。

最后一点，这些*_join函数与 SQL 语法非常相关，但强调数据分析中常见的操作。

##学习评估：
此 zip 文件中的数据集包含本课程往年调查问卷的去识别化回复。两个数据集都包含唯一的学生标识符；第一个数据集包含关于操作系统的问题的回复，第二个数据集包含关于学位课程和 Git 经验的问题的回复。请编写一个代码块，导入并清理这两个数据集，然后将它们连接起来。

##解决方案
我将两个数据集都放在了data我的 repo / 项目的目录中。下面的代码导入了这两个数据集，清理了变量名，并使用left_join、 inner_join和连接这两个数据集anti_join。
```{r}
surv_os = 
  read_csv("data/surv_os.csv") |>                                     # 读取 surv_os.csv 文件
  janitor::clean_names() |>                                           # 清理列名为小写加下划线格式
  rename(id = what_is_your_uni,                                       # 重命名列：将 "what_is_your_uni" 改为 "id"
         os = what_operating_system_do_you_use)                       # 重命名列："what_operating_system_do_you_use" 改为 "os"

surv_pr_git = 
  read_csv("data/surv_program_git.csv") |>                           # 读取 surv_program_git.csv 文件
  janitor::clean_names() |>                                          # 清理列名
  rename(                                                            # 重命名多列
    id = what_is_your_uni,                                           # "what_is_your_uni" 改为 "id"
    prog = what_is_your_degree_program,                              # "what_is_your_degree_program" 改为 "prog"
    git_exp = which_most_accurately_describes_your_experience_with_git)#改为 "git_exp"

left_join(surv_os, surv_pr_git)                                     # 左连接，保留 surv_os 所有行，匹配 surv_pr_git 的信息
inner_join(surv_os, surv_pr_git)                                    # 内连接，只保留两个表都存在的 id 行
anti_join(surv_os, surv_pr_git)                                     # 反连接，保留 surv_os 中不在 surv_pr_git 的 id 行
anti_join(surv_pr_git, surv_os)                                     # 反连接，保留 surv_pr_git 中不在 surv_os 的 id 行

```

left_join和inner_join都给出了关于“多对多”关系的警告。这表明匹配的变量不唯一，应该对警告进行调查。
在下面的代码中，我们来分析一下“第 7 行中x 与 中的多行匹配y”这个警告。

```{r}
surv_os |> slice(7)
surv_pr_git |> filter(id == "student_15")
```

##关于名字的简要说明
有一段时间，人们使用gatherand spread而不是pivot_longer and pivot_wider。
新功能的更新是有充分理由的；gatherandspread仍将存在，但随着时间的推移，它们将变得不那么常见，您可能永远不会再看到它们。
